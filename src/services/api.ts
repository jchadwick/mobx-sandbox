/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * techbash
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://techbash.com".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface BulkEmailMessage
 */
export interface BulkEmailMessage {
    /**
     * 
     * @type {Array<string>}
     * @memberof BulkEmailMessage
     */
    recipients?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof BulkEmailMessage
     */
    subject?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkEmailMessage
     */
    body?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkEmailMessage
     */
    replyTo?: string;
}

/**
 * 
 * @export
 * @interface Evaluation
 */
export interface Evaluation {
    /**
     * 
     * @type {number}
     * @memberof Evaluation
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof Evaluation
     */
    timestamp?: Date;
    /**
     * 
     * @type {number}
     * @memberof Evaluation
     */
    year?: number;
    /**
     * 
     * @type {string}
     * @memberof Evaluation
     */
    userId?: string;
    /**
     * 
     * @type {number}
     * @memberof Evaluation
     */
    sessionId?: number;
    /**
     * 
     * @type {any}
     * @memberof Evaluation
     */
    responses?: any;
}

/**
 * 
 * @export
 * @interface EvaluationSummary
 */
export interface EvaluationSummary {
    /**
     * 
     * @type {number}
     * @memberof EvaluationSummary
     */
    sessionId?: number;
    /**
     * 
     * @type {string}
     * @memberof EvaluationSummary
     */
    sessionKey?: string;
    /**
     * 
     * @type {string}
     * @memberof EvaluationSummary
     */
    sessionTitle?: string;
    /**
     * 
     * @type {number}
     * @memberof EvaluationSummary
     */
    speakerId?: number;
    /**
     * 
     * @type {string}
     * @memberof EvaluationSummary
     */
    speakerKey?: string;
    /**
     * 
     * @type {string}
     * @memberof EvaluationSummary
     */
    speakerName?: string;
    /**
     * 
     * @type {number}
     * @memberof EvaluationSummary
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof EvaluationSummary
     */
    rating?: number;
}

/**
 * 
 * @export
 * @interface EvaluationSummaryViewModel
 */
export interface EvaluationSummaryViewModel {
    /**
     * 
     * @type {number}
     * @memberof EvaluationSummaryViewModel
     */
    overall?: number;
    /**
     * 
     * @type {number}
     * @memberof EvaluationSummaryViewModel
     */
    presentation?: number;
    /**
     * 
     * @type {number}
     * @memberof EvaluationSummaryViewModel
     */
    content?: number;
    /**
     * 
     * @type {number}
     * @memberof EvaluationSummaryViewModel
     */
    knowledge?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof EvaluationSummaryViewModel
     */
    comments?: Array<string>;
    /**
     * 
     * @type {Array<SessionEvaluationSummary>}
     * @memberof EvaluationSummaryViewModel
     */
    sessions?: Array<SessionEvaluationSummary>;
    /**
     * 
     * @type {Array<SpeakerEvaluationSummary>}
     * @memberof EvaluationSummaryViewModel
     */
    speakers?: Array<SpeakerEvaluationSummary>;
    /**
     * 
     * @type {Array<Evaluation>}
     * @memberof EvaluationSummaryViewModel
     */
    evaluations?: Array<Evaluation>;
}

/**
 * 
 * @export
 * @interface Location
 */
export interface Location {
    /**
     * 
     * @type {number}
     * @memberof Location
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof Location
     */
    ordinal?: number;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof Location
     */
    year?: number;
}

/**
 * 
 * @export
 * @interface LocationSessionViewModel
 */
export interface LocationSessionViewModel {
    /**
     * 
     * @type {string}
     * @memberof LocationSessionViewModel
     */
    time?: string;
    /**
     * 
     * @type {Date}
     * @memberof LocationSessionViewModel
     */
    startTime?: Date;
    /**
     * 
     * @type {string}
     * @memberof LocationSessionViewModel
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof LocationSessionViewModel
     */
    speaker?: string;
}

/**
 * 
 * @export
 * @interface LocationSessionsViewModel
 */
export interface LocationSessionsViewModel {
    /**
     * 
     * @type {string}
     * @memberof LocationSessionsViewModel
     */
    location?: string;
    /**
     * 
     * @type {string}
     * @memberof LocationSessionsViewModel
     */
    day?: string;
    /**
     * 
     * @type {Array<LocationSessionViewModel>}
     * @memberof LocationSessionsViewModel
     */
    sessions?: Array<LocationSessionViewModel>;
}

/**
 * 
 * @export
 * @interface QuickSubmission
 */
export interface QuickSubmission {
    /**
     * 
     * @type {string}
     * @memberof QuickSubmission
     */
    speakerKey?: string;
    /**
     * 
     * @type {string}
     * @memberof QuickSubmission
     */
    speakerName?: string;
    /**
     * 
     * @type {string}
     * @memberof QuickSubmission
     */
    bio?: string;
    /**
     * 
     * @type {string}
     * @memberof QuickSubmission
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof QuickSubmission
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof QuickSubmission
     */
    year?: number;
    /**
     * 
     * @type {boolean}
     * @memberof QuickSubmission
     */
    isNewSpeaker?: boolean;
}

/**
 * 
 * @export
 * @interface ScheduleSubmissionRequest
 */
export interface ScheduleSubmissionRequest {
    /**
     * 
     * @type {number}
     * @memberof ScheduleSubmissionRequest
     */
    submissionId?: number;
    /**
     * 
     * @type {number}
     * @memberof ScheduleSubmissionRequest
     */
    timeSlotId?: number;
    /**
     * 
     * @type {number}
     * @memberof ScheduleSubmissionRequest
     */
    locationId?: number;
}

/**
 * 
 * @export
 * @interface Session
 */
export interface Session {
    /**
     * 
     * @type {number}
     * @memberof Session
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    key?: string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    type?: Session.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    description: string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    length: Session.LengthEnum;
    /**
     * 
     * @type {number}
     * @memberof Session
     */
    categoryId: number;
    /**
     * 
     * @type {number}
     * @memberof Session
     */
    speakerId: number;
    /**
     * 
     * @type {number}
     * @memberof Session
     */
    timeSlotId?: number;
    /**
     * 
     * @type {number}
     * @memberof Session
     */
    year?: number;
    /**
     * 
     * @type {number}
     * @memberof Session
     */
    locationId?: number;
    /**
     * 
     * @type {number}
     * @memberof Session
     */
    attendeeCount?: number;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    displayName?: string;
}

/**
 * @export
 * @namespace Session
 */
export namespace Session {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Presentation = <any> 'Presentation',
        Keynote = <any> 'Keynote',
        Break = <any> 'Break',
        Reserved = <any> 'Reserved'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum LengthEnum {
        Short = <any> 'Short',
        Medium = <any> 'Medium',
        Long = <any> 'Long',
        Lightning = <any> 'Lightning'
    }
}

/**
 * 
 * @export
 * @interface SessionEvaluationSummary
 */
export interface SessionEvaluationSummary {
    /**
     * 
     * @type {string}
     * @memberof SessionEvaluationSummary
     */
    sessionKey?: string;
    /**
     * 
     * @type {string}
     * @memberof SessionEvaluationSummary
     */
    sessionTitle?: string;
    /**
     * 
     * @type {number}
     * @memberof SessionEvaluationSummary
     */
    overall?: number;
    /**
     * 
     * @type {number}
     * @memberof SessionEvaluationSummary
     */
    presentation?: number;
    /**
     * 
     * @type {number}
     * @memberof SessionEvaluationSummary
     */
    content?: number;
    /**
     * 
     * @type {number}
     * @memberof SessionEvaluationSummary
     */
    knowledge?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof SessionEvaluationSummary
     */
    comments?: Array<string>;
    /**
     * 
     * @type {Array<SessionEvaluationSummary>}
     * @memberof SessionEvaluationSummary
     */
    sessions?: Array<SessionEvaluationSummary>;
    /**
     * 
     * @type {Array<SpeakerEvaluationSummary>}
     * @memberof SessionEvaluationSummary
     */
    speakers?: Array<SpeakerEvaluationSummary>;
    /**
     * 
     * @type {Array<Evaluation>}
     * @memberof SessionEvaluationSummary
     */
    evaluations?: Array<Evaluation>;
}

/**
 * 
 * @export
 * @interface Speaker
 */
export interface Speaker {
    /**
     * 
     * @type {number}
     * @memberof Speaker
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Speaker
     */
    key?: string;
    /**
     * 
     * @type {string}
     * @memberof Speaker
     */
    userId?: string;
    /**
     * 
     * @type {string}
     * @memberof Speaker
     */
    gender?: Speaker.GenderEnum;
    /**
     * 
     * @type {string}
     * @memberof Speaker
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Speaker
     */
    biography?: string;
    /**
     * 
     * @type {string}
     * @memberof Speaker
     */
    avatarUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof Speaker
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof Speaker
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof Speaker
     */
    country?: string;
    /**
     * 
     * @type {string}
     * @memberof Speaker
     */
    company?: string;
}

/**
 * @export
 * @namespace Speaker
 */
export namespace Speaker {
    /**
     * @export
     * @enum {string}
     */
    export enum GenderEnum {
        Undisclosed = <any> 'Undisclosed',
        Male = <any> 'Male',
        Female = <any> 'Female',
        Complicated = <any> 'Complicated'
    }
}

/**
 * 
 * @export
 * @interface SpeakerEvaluationSummary
 */
export interface SpeakerEvaluationSummary {
    /**
     * 
     * @type {string}
     * @memberof SpeakerEvaluationSummary
     */
    speakerKey?: string;
    /**
     * 
     * @type {string}
     * @memberof SpeakerEvaluationSummary
     */
    speakerName?: string;
    /**
     * 
     * @type {number}
     * @memberof SpeakerEvaluationSummary
     */
    overall?: number;
    /**
     * 
     * @type {number}
     * @memberof SpeakerEvaluationSummary
     */
    presentation?: number;
    /**
     * 
     * @type {number}
     * @memberof SpeakerEvaluationSummary
     */
    content?: number;
    /**
     * 
     * @type {number}
     * @memberof SpeakerEvaluationSummary
     */
    knowledge?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof SpeakerEvaluationSummary
     */
    comments?: Array<string>;
    /**
     * 
     * @type {Array<SessionEvaluationSummary>}
     * @memberof SpeakerEvaluationSummary
     */
    sessions?: Array<SessionEvaluationSummary>;
    /**
     * 
     * @type {Array<SpeakerEvaluationSummary>}
     * @memberof SpeakerEvaluationSummary
     */
    speakers?: Array<SpeakerEvaluationSummary>;
    /**
     * 
     * @type {Array<Evaluation>}
     * @memberof SpeakerEvaluationSummary
     */
    evaluations?: Array<Evaluation>;
}

/**
 * 
 * @export
 * @interface Submission
 */
export interface Submission {
    /**
     * 
     * @type {number}
     * @memberof Submission
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof Submission
     */
    submitDate?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof Submission
     */
    accepted?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Submission
     */
    speakerId?: number;
    /**
     * 
     * @type {number}
     * @memberof Submission
     */
    sessionId?: number;
    /**
     * 
     * @type {string}
     * @memberof Submission
     */
    length: Submission.LengthEnum;
    /**
     * 
     * @type {string}
     * @memberof Submission
     */
    status?: Submission.StatusEnum;
    /**
     * 
     * @type {number}
     * @memberof Submission
     */
    categoryId: number;
    /**
     * 
     * @type {string}
     * @memberof Submission
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof Submission
     */
    description: string;
    /**
     * 
     * @type {number}
     * @memberof Submission
     */
    year?: number;
}

/**
 * @export
 * @namespace Submission
 */
export namespace Submission {
    /**
     * @export
     * @enum {string}
     */
    export enum LengthEnum {
        Short = <any> 'Short',
        Medium = <any> 'Medium',
        Long = <any> 'Long',
        Lightning = <any> 'Lightning'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Submitted = <any> 'Submitted',
        Selected = <any> 'Selected',
        Alternate = <any> 'Alternate',
        Rejected = <any> 'Rejected',
        Accepted = <any> 'Accepted',
        Withdrawn = <any> 'Withdrawn'
    }
}

/**
 * 
 * @export
 * @interface TimeSlot
 */
export interface TimeSlot {
    /**
     * 
     * @type {number}
     * @memberof TimeSlot
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof TimeSlot
     */
    startTime?: Date;
    /**
     * 
     * @type {string}
     * @memberof TimeSlot
     */
    length?: TimeSlot.LengthEnum;
    /**
     * 
     * @type {number}
     * @memberof TimeSlot
     */
    year?: number;
    /**
     * 
     * @type {Date}
     * @memberof TimeSlot
     */
    date?: Date;
    /**
     * 
     * @type {string}
     * @memberof TimeSlot
     */
    duration?: string;
}

/**
 * @export
 * @namespace TimeSlot
 */
export namespace TimeSlot {
    /**
     * @export
     * @enum {string}
     */
    export enum LengthEnum {
        Short = <any> 'Short',
        Medium = <any> 'Medium',
        Long = <any> 'Long',
        Lightning = <any> 'Lightning'
    }
}

/**
 * 
 * @export
 * @interface UserInfo
 */
export interface UserInfo {
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    key?: string;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    gender?: UserInfo.GenderEnum;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    avatarUrl?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserInfo
     */
    roles?: Array<string>;
}

/**
 * @export
 * @namespace UserInfo
 */
export namespace UserInfo {
    /**
     * @export
     * @enum {string}
     */
    export enum GenderEnum {
        Undisclosed = <any> 'Undisclosed',
        Male = <any> 'Male',
        Female = <any> 'Female',
        Complicated = <any> 'Complicated'
    }
}


/**
 * EvaluationsApi - fetch parameter creator
 * @export
 */
export const EvaluationsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} evaluationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationsGetEvaluation(evaluationId: number, options: any = {}): FetchArgs {
            // verify required parameter 'evaluationId' is not null or undefined
            if (evaluationId === null || evaluationId === undefined) {
                throw new RequiredError('evaluationId','Required parameter evaluationId was null or undefined when calling evaluationsGetEvaluation.');
            }
            const localVarPath = `/api/evals/{evaluationId}`
                .replace(`{${"evaluationId"}}`, encodeURIComponent(String(evaluationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationsGetEvaluationsBySession(key: string, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling evaluationsGetEvaluationsBySession.');
            }
            const localVarPath = `/api/sessions/{key}/evals`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} key 
         * @param {number} [year] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationsGetEvaluationsBySpeaker(key: string, year?: number, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling evaluationsGetEvaluationsBySpeaker.');
            }
            const localVarPath = `/api/speakers/{key}/evals`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (year !== undefined) {
                localVarQueryParameter['year'] = year;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [year] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationsGetSessionEvaluations(year?: number, options: any = {}): FetchArgs {
            const localVarPath = `/api/evals`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (year !== undefined) {
                localVarQueryParameter['year'] = year;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {any} responses 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationsSubmitConferenceEvaluation(responses: any, options: any = {}): FetchArgs {
            // verify required parameter 'responses' is not null or undefined
            if (responses === null || responses === undefined) {
                throw new RequiredError('responses','Required parameter responses was null or undefined when calling evaluationsSubmitConferenceEvaluation.');
            }
            const localVarPath = `/api/evals/conference`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"any" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(responses || {}) : (responses || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {any} responses 
         * @param {number} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationsSubmitSessionEvaluation(responses: any, sessionId: number, options: any = {}): FetchArgs {
            // verify required parameter 'responses' is not null or undefined
            if (responses === null || responses === undefined) {
                throw new RequiredError('responses','Required parameter responses was null or undefined when calling evaluationsSubmitSessionEvaluation.');
            }
            // verify required parameter 'sessionId' is not null or undefined
            if (sessionId === null || sessionId === undefined) {
                throw new RequiredError('sessionId','Required parameter sessionId was null or undefined when calling evaluationsSubmitSessionEvaluation.');
            }
            const localVarPath = `/api/evals/sessions/{sessionId}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"any" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(responses || {}) : (responses || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EvaluationsApi - functional programming interface
 * @export
 */
export const EvaluationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} evaluationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationsGetEvaluation(evaluationId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = EvaluationsApiFetchParamCreator(configuration).evaluationsGetEvaluation(evaluationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationsGetEvaluationsBySession(key: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EvaluationSummaryViewModel> {
            const localVarFetchArgs = EvaluationsApiFetchParamCreator(configuration).evaluationsGetEvaluationsBySession(key, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} key 
         * @param {number} [year] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationsGetEvaluationsBySpeaker(key: string, year?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EvaluationSummaryViewModel> {
            const localVarFetchArgs = EvaluationsApiFetchParamCreator(configuration).evaluationsGetEvaluationsBySpeaker(key, year, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [year] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationsGetSessionEvaluations(year?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EvaluationSummaryViewModel>> {
            const localVarFetchArgs = EvaluationsApiFetchParamCreator(configuration).evaluationsGetSessionEvaluations(year, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {any} responses 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationsSubmitConferenceEvaluation(responses: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = EvaluationsApiFetchParamCreator(configuration).evaluationsSubmitConferenceEvaluation(responses, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {any} responses 
         * @param {number} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationsSubmitSessionEvaluation(responses: any, sessionId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = EvaluationsApiFetchParamCreator(configuration).evaluationsSubmitSessionEvaluation(responses, sessionId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EvaluationsApi - factory interface
 * @export
 */
export const EvaluationsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {number} evaluationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationsGetEvaluation(evaluationId: number, options?: any) {
            return EvaluationsApiFp(configuration).evaluationsGetEvaluation(evaluationId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationsGetEvaluationsBySession(key: string, options?: any) {
            return EvaluationsApiFp(configuration).evaluationsGetEvaluationsBySession(key, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} key 
         * @param {number} [year] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationsGetEvaluationsBySpeaker(key: string, year?: number, options?: any) {
            return EvaluationsApiFp(configuration).evaluationsGetEvaluationsBySpeaker(key, year, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [year] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationsGetSessionEvaluations(year?: number, options?: any) {
            return EvaluationsApiFp(configuration).evaluationsGetSessionEvaluations(year, options)(fetch, basePath);
        },
        /**
         * 
         * @param {any} responses 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationsSubmitConferenceEvaluation(responses: any, options?: any) {
            return EvaluationsApiFp(configuration).evaluationsSubmitConferenceEvaluation(responses, options)(fetch, basePath);
        },
        /**
         * 
         * @param {any} responses 
         * @param {number} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationsSubmitSessionEvaluation(responses: any, sessionId: number, options?: any) {
            return EvaluationsApiFp(configuration).evaluationsSubmitSessionEvaluation(responses, sessionId, options)(fetch, basePath);
        },
    };
};

/**
 * EvaluationsApi - object-oriented interface
 * @export
 * @class EvaluationsApi
 * @extends {BaseAPI}
 */
export class EvaluationsApi extends BaseAPI {
    /**
     * 
     * @param {number} evaluationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EvaluationsApi
     */
    public evaluationsGetEvaluation(evaluationId: number, options?: any) {
        return EvaluationsApiFp(this.configuration).evaluationsGetEvaluation(evaluationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} key 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EvaluationsApi
     */
    public evaluationsGetEvaluationsBySession(key: string, options?: any) {
        return EvaluationsApiFp(this.configuration).evaluationsGetEvaluationsBySession(key, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} key 
     * @param {number} [year] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EvaluationsApi
     */
    public evaluationsGetEvaluationsBySpeaker(key: string, year?: number, options?: any) {
        return EvaluationsApiFp(this.configuration).evaluationsGetEvaluationsBySpeaker(key, year, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [year] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EvaluationsApi
     */
    public evaluationsGetSessionEvaluations(year?: number, options?: any) {
        return EvaluationsApiFp(this.configuration).evaluationsGetSessionEvaluations(year, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {any} responses 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EvaluationsApi
     */
    public evaluationsSubmitConferenceEvaluation(responses: any, options?: any) {
        return EvaluationsApiFp(this.configuration).evaluationsSubmitConferenceEvaluation(responses, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {any} responses 
     * @param {number} sessionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EvaluationsApi
     */
    public evaluationsSubmitSessionEvaluation(responses: any, sessionId: number, options?: any) {
        return EvaluationsApiFp(this.configuration).evaluationsSubmitSessionEvaluation(responses, sessionId, options)(this.fetch, this.basePath);
    }

}

/**
 * LocationsApi - fetch parameter creator
 * @export
 */
export const LocationsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationsGet(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling locationsGet.');
            }
            const localVarPath = `/api/locations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [year] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationsGet_1(year?: number, options: any = {}): FetchArgs {
            const localVarPath = `/api/Locations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (year !== undefined) {
                localVarQueryParameter['year'] = year;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} locationId 
         * @param {Date} [day] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationsSessions(locationId: number, day?: Date, options: any = {}): FetchArgs {
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling locationsSessions.');
            }
            const localVarPath = `/api/locations/{locationId}/sessions`
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (day !== undefined) {
                localVarQueryParameter['day'] = (day as any).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LocationsApi - functional programming interface
 * @export
 */
export const LocationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationsGet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Location> {
            const localVarFetchArgs = LocationsApiFetchParamCreator(configuration).locationsGet(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [year] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationsGet_1(year?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Location>> {
            const localVarFetchArgs = LocationsApiFetchParamCreator(configuration).locationsGet_1(year, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} locationId 
         * @param {Date} [day] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationsSessions(locationId: number, day?: Date, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LocationSessionsViewModel> {
            const localVarFetchArgs = LocationsApiFetchParamCreator(configuration).locationsSessions(locationId, day, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * LocationsApi - factory interface
 * @export
 */
export const LocationsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationsGet(id: number, options?: any) {
            return LocationsApiFp(configuration).locationsGet(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [year] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationsGet_1(year?: number, options?: any) {
            return LocationsApiFp(configuration).locationsGet_1(year, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} locationId 
         * @param {Date} [day] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationsSessions(locationId: number, day?: Date, options?: any) {
            return LocationsApiFp(configuration).locationsSessions(locationId, day, options)(fetch, basePath);
        },
    };
};

/**
 * LocationsApi - object-oriented interface
 * @export
 * @class LocationsApi
 * @extends {BaseAPI}
 */
export class LocationsApi extends BaseAPI {
    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationsApi
     */
    public locationsGet(id: number, options?: any) {
        return LocationsApiFp(this.configuration).locationsGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [year] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationsApi
     */
    public locationsGet_1(year?: number, options?: any) {
        return LocationsApiFp(this.configuration).locationsGet_1(year, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} locationId 
     * @param {Date} [day] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationsApi
     */
    public locationsSessions(locationId: number, day?: Date, options?: any) {
        return LocationsApiFp(this.configuration).locationsSessions(locationId, day, options)(this.fetch, this.basePath);
    }

}

/**
 * RatingsApi - fetch parameter creator
 * @export
 */
export const RatingsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [speaker] 
         * @param {string} [session] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ratingsRatings(speaker?: string, session?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/ratings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (speaker !== undefined) {
                localVarQueryParameter['speaker'] = speaker;
            }

            if (session !== undefined) {
                localVarQueryParameter['session'] = session;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ratingsSessionRating(key: string, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling ratingsSessionRating.');
            }
            const localVarPath = `/api/sessions/{key}/rating`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ratingsSpeakerRatings(key: string, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling ratingsSpeakerRatings.');
            }
            const localVarPath = `/api/speakers/{key}/ratings`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RatingsApi - functional programming interface
 * @export
 */
export const RatingsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [speaker] 
         * @param {string} [session] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ratingsRatings(speaker?: string, session?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EvaluationSummary>> {
            const localVarFetchArgs = RatingsApiFetchParamCreator(configuration).ratingsRatings(speaker, session, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ratingsSessionRating(key: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = RatingsApiFetchParamCreator(configuration).ratingsSessionRating(key, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ratingsSpeakerRatings(key: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = RatingsApiFetchParamCreator(configuration).ratingsSpeakerRatings(key, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RatingsApi - factory interface
 * @export
 */
export const RatingsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} [speaker] 
         * @param {string} [session] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ratingsRatings(speaker?: string, session?: string, options?: any) {
            return RatingsApiFp(configuration).ratingsRatings(speaker, session, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ratingsSessionRating(key: string, options?: any) {
            return RatingsApiFp(configuration).ratingsSessionRating(key, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ratingsSpeakerRatings(key: string, options?: any) {
            return RatingsApiFp(configuration).ratingsSpeakerRatings(key, options)(fetch, basePath);
        },
    };
};

/**
 * RatingsApi - object-oriented interface
 * @export
 * @class RatingsApi
 * @extends {BaseAPI}
 */
export class RatingsApi extends BaseAPI {
    /**
     * 
     * @param {string} [speaker] 
     * @param {string} [session] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RatingsApi
     */
    public ratingsRatings(speaker?: string, session?: string, options?: any) {
        return RatingsApiFp(this.configuration).ratingsRatings(speaker, session, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} key 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RatingsApi
     */
    public ratingsSessionRating(key: string, options?: any) {
        return RatingsApiFp(this.configuration).ratingsSessionRating(key, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} key 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RatingsApi
     */
    public ratingsSpeakerRatings(key: string, options?: any) {
        return RatingsApiFp(this.configuration).ratingsSpeakerRatings(key, options)(this.fetch, this.basePath);
    }

}

/**
 * SessionsApi - fetch parameter creator
 * @export
 */
export const SessionsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionsGet(key: string, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling sessionsGet.');
            }
            const localVarPath = `/api/sessions/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionsGet_1(options: any = {}): FetchArgs {
            const localVarPath = `/api/Sessions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} year 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionsStats(year: number, options: any = {}): FetchArgs {
            // verify required parameter 'year' is not null or undefined
            if (year === null || year === undefined) {
                throw new RequiredError('year','Required parameter year was null or undefined when calling sessionsStats.');
            }
            const localVarPath = `/api/sessions/stats`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (year !== undefined) {
                localVarQueryParameter['year'] = year;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} key 
         * @param {Session} updated 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionsUpdate(key: string, updated: Session, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling sessionsUpdate.');
            }
            // verify required parameter 'updated' is not null or undefined
            if (updated === null || updated === undefined) {
                throw new RequiredError('updated','Required parameter updated was null or undefined when calling sessionsUpdate.');
            }
            const localVarPath = `/api/sessions/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Session" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updated || {}) : (updated || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SessionsApi - functional programming interface
 * @export
 */
export const SessionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionsGet(key: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = SessionsApiFetchParamCreator(configuration).sessionsGet(key, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionsGet_1(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Session>> {
            const localVarFetchArgs = SessionsApiFetchParamCreator(configuration).sessionsGet_1(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} year 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionsStats(year: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = SessionsApiFetchParamCreator(configuration).sessionsStats(year, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} key 
         * @param {Session} updated 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionsUpdate(key: string, updated: Session, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = SessionsApiFetchParamCreator(configuration).sessionsUpdate(key, updated, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SessionsApi - factory interface
 * @export
 */
export const SessionsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionsGet(key: string, options?: any) {
            return SessionsApiFp(configuration).sessionsGet(key, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionsGet_1(options?: any) {
            return SessionsApiFp(configuration).sessionsGet_1(options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} year 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionsStats(year: number, options?: any) {
            return SessionsApiFp(configuration).sessionsStats(year, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} key 
         * @param {Session} updated 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionsUpdate(key: string, updated: Session, options?: any) {
            return SessionsApiFp(configuration).sessionsUpdate(key, updated, options)(fetch, basePath);
        },
    };
};

/**
 * SessionsApi - object-oriented interface
 * @export
 * @class SessionsApi
 * @extends {BaseAPI}
 */
export class SessionsApi extends BaseAPI {
    /**
     * 
     * @param {string} key 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public sessionsGet(key: string, options?: any) {
        return SessionsApiFp(this.configuration).sessionsGet(key, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public sessionsGet_1(options?: any) {
        return SessionsApiFp(this.configuration).sessionsGet_1(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} year 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public sessionsStats(year: number, options?: any) {
        return SessionsApiFp(this.configuration).sessionsStats(year, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} key 
     * @param {Session} updated 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public sessionsUpdate(key: string, updated: Session, options?: any) {
        return SessionsApiFp(this.configuration).sessionsUpdate(key, updated, options)(this.fetch, this.basePath);
    }

}

/**
 * SpeakersApi - fetch parameter creator
 * @export
 */
export const SpeakersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {string} company 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        speakersCompany(id: number, company: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling speakersCompany.');
            }
            // verify required parameter 'company' is not null or undefined
            if (company === null || company === undefined) {
                throw new RequiredError('company','Required parameter company was null or undefined when calling speakersCompany.');
            }
            const localVarPath = `/api/speakers/{id}/company`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(company || {}) : (company || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        speakersGet(query?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/speakers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        speakersGet_1(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling speakersGet_1.');
            }
            const localVarPath = `/api/speakers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {string} notes 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        speakersNotes(id: number, notes: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling speakersNotes.');
            }
            // verify required parameter 'notes' is not null or undefined
            if (notes === null || notes === undefined) {
                throw new RequiredError('notes','Required parameter notes was null or undefined when calling speakersNotes.');
            }
            const localVarPath = `/api/speakers/{id}/notes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(notes || {}) : (notes || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {BulkEmailMessage} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        speakersSendEmail(request: BulkEmailMessage, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling speakersSendEmail.');
            }
            const localVarPath = `/api/speakers/email`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BulkEmailMessage" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} key 
         * @param {number} year 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        speakersWithdraw(key: string, year: number, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling speakersWithdraw.');
            }
            // verify required parameter 'year' is not null or undefined
            if (year === null || year === undefined) {
                throw new RequiredError('year','Required parameter year was null or undefined when calling speakersWithdraw.');
            }
            const localVarPath = `/api/speakers/{key}/withdraw`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (year !== undefined) {
                localVarQueryParameter['year'] = year;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SpeakersApi - functional programming interface
 * @export
 */
export const SpeakersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {string} company 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        speakersCompany(id: number, company: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = SpeakersApiFetchParamCreator(configuration).speakersCompany(id, company, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        speakersGet(query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Speaker>> {
            const localVarFetchArgs = SpeakersApiFetchParamCreator(configuration).speakersGet(query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        speakersGet_1(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Speaker> {
            const localVarFetchArgs = SpeakersApiFetchParamCreator(configuration).speakersGet_1(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {string} notes 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        speakersNotes(id: number, notes: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = SpeakersApiFetchParamCreator(configuration).speakersNotes(id, notes, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {BulkEmailMessage} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        speakersSendEmail(request: BulkEmailMessage, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = SpeakersApiFetchParamCreator(configuration).speakersSendEmail(request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} key 
         * @param {number} year 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        speakersWithdraw(key: string, year: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = SpeakersApiFetchParamCreator(configuration).speakersWithdraw(key, year, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SpeakersApi - factory interface
 * @export
 */
export const SpeakersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {string} company 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        speakersCompany(id: number, company: string, options?: any) {
            return SpeakersApiFp(configuration).speakersCompany(id, company, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        speakersGet(query?: string, options?: any) {
            return SpeakersApiFp(configuration).speakersGet(query, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        speakersGet_1(id: number, options?: any) {
            return SpeakersApiFp(configuration).speakersGet_1(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {string} notes 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        speakersNotes(id: number, notes: string, options?: any) {
            return SpeakersApiFp(configuration).speakersNotes(id, notes, options)(fetch, basePath);
        },
        /**
         * 
         * @param {BulkEmailMessage} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        speakersSendEmail(request: BulkEmailMessage, options?: any) {
            return SpeakersApiFp(configuration).speakersSendEmail(request, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} key 
         * @param {number} year 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        speakersWithdraw(key: string, year: number, options?: any) {
            return SpeakersApiFp(configuration).speakersWithdraw(key, year, options)(fetch, basePath);
        },
    };
};

/**
 * SpeakersApi - object-oriented interface
 * @export
 * @class SpeakersApi
 * @extends {BaseAPI}
 */
export class SpeakersApi extends BaseAPI {
    /**
     * 
     * @param {number} id 
     * @param {string} company 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpeakersApi
     */
    public speakersCompany(id: number, company: string, options?: any) {
        return SpeakersApiFp(this.configuration).speakersCompany(id, company, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [query] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpeakersApi
     */
    public speakersGet(query?: string, options?: any) {
        return SpeakersApiFp(this.configuration).speakersGet(query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpeakersApi
     */
    public speakersGet_1(id: number, options?: any) {
        return SpeakersApiFp(this.configuration).speakersGet_1(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {string} notes 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpeakersApi
     */
    public speakersNotes(id: number, notes: string, options?: any) {
        return SpeakersApiFp(this.configuration).speakersNotes(id, notes, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {BulkEmailMessage} request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpeakersApi
     */
    public speakersSendEmail(request: BulkEmailMessage, options?: any) {
        return SpeakersApiFp(this.configuration).speakersSendEmail(request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} key 
     * @param {number} year 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpeakersApi
     */
    public speakersWithdraw(key: string, year: number, options?: any) {
        return SpeakersApiFp(this.configuration).speakersWithdraw(key, year, options)(this.fetch, this.basePath);
    }

}

/**
 * SubmissionsApi - fetch parameter creator
 * @export
 */
export const SubmissionsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} submissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsAccept(submissionId: number, options: any = {}): FetchArgs {
            // verify required parameter 'submissionId' is not null or undefined
            if (submissionId === null || submissionId === undefined) {
                throw new RequiredError('submissionId','Required parameter submissionId was null or undefined when calling submissionsAccept.');
            }
            const localVarPath = `/api/submissions/{submissionId}/accept`
                .replace(`{${"submissionId"}}`, encodeURIComponent(String(submissionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} submissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsDelete(submissionId: number, options: any = {}): FetchArgs {
            // verify required parameter 'submissionId' is not null or undefined
            if (submissionId === null || submissionId === undefined) {
                throw new RequiredError('submissionId','Required parameter submissionId was null or undefined when calling submissionsDelete.');
            }
            const localVarPath = `/api/submissions/{submissionId}`
                .replace(`{${"submissionId"}}`, encodeURIComponent(String(submissionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsGet(options: any = {}): FetchArgs {
            const localVarPath = `/api/submissions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} submissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsGet_1(submissionId: number, options: any = {}): FetchArgs {
            // verify required parameter 'submissionId' is not null or undefined
            if (submissionId === null || submissionId === undefined) {
                throw new RequiredError('submissionId','Required parameter submissionId was null or undefined when calling submissionsGet_1.');
            }
            const localVarPath = `/api/submissions/{submissionId}`
                .replace(`{${"submissionId"}}`, encodeURIComponent(String(submissionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {QuickSubmission} submission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsQuickSubmit(submission: QuickSubmission, options: any = {}): FetchArgs {
            // verify required parameter 'submission' is not null or undefined
            if (submission === null || submission === undefined) {
                throw new RequiredError('submission','Required parameter submission was null or undefined when calling submissionsQuickSubmit.');
            }
            const localVarPath = `/api/submissions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"QuickSubmission" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(submission || {}) : (submission || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} submissionId 
         * @param {number} rating 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsRate(submissionId: number, rating: number, options: any = {}): FetchArgs {
            // verify required parameter 'submissionId' is not null or undefined
            if (submissionId === null || submissionId === undefined) {
                throw new RequiredError('submissionId','Required parameter submissionId was null or undefined when calling submissionsRate.');
            }
            // verify required parameter 'rating' is not null or undefined
            if (rating === null || rating === undefined) {
                throw new RequiredError('rating','Required parameter rating was null or undefined when calling submissionsRate.');
            }
            const localVarPath = `/api/submissions/{submissionId}/rate`
                .replace(`{${"submissionId"}}`, encodeURIComponent(String(submissionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (rating !== undefined) {
                localVarQueryParameter['rating'] = rating;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} submissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsReject(submissionId: number, options: any = {}): FetchArgs {
            // verify required parameter 'submissionId' is not null or undefined
            if (submissionId === null || submissionId === undefined) {
                throw new RequiredError('submissionId','Required parameter submissionId was null or undefined when calling submissionsReject.');
            }
            const localVarPath = `/api/submissions/{submissionId}/reject`
                .replace(`{${"submissionId"}}`, encodeURIComponent(String(submissionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} submissionId 
         * @param {ScheduleSubmissionRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsSchedule(submissionId: number, request: ScheduleSubmissionRequest, options: any = {}): FetchArgs {
            // verify required parameter 'submissionId' is not null or undefined
            if (submissionId === null || submissionId === undefined) {
                throw new RequiredError('submissionId','Required parameter submissionId was null or undefined when calling submissionsSchedule.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling submissionsSchedule.');
            }
            const localVarPath = `/api/submissions/{submissionId}/schedule`
                .replace(`{${"submissionId"}}`, encodeURIComponent(String(submissionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ScheduleSubmissionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} submissionId 
         * @param {boolean} [isAlternate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsSelect(submissionId: number, isAlternate?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'submissionId' is not null or undefined
            if (submissionId === null || submissionId === undefined) {
                throw new RequiredError('submissionId','Required parameter submissionId was null or undefined when calling submissionsSelect.');
            }
            const localVarPath = `/api/submissions/{submissionId}/select`
                .replace(`{${"submissionId"}}`, encodeURIComponent(String(submissionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isAlternate !== undefined) {
                localVarQueryParameter['isAlternate'] = isAlternate;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} year 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsStats(year: number, options: any = {}): FetchArgs {
            // verify required parameter 'year' is not null or undefined
            if (year === null || year === undefined) {
                throw new RequiredError('year','Required parameter year was null or undefined when calling submissionsStats.');
            }
            const localVarPath = `/api/submissions/stats`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (year !== undefined) {
                localVarQueryParameter['year'] = year;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} submissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsUnaccept(submissionId: number, options: any = {}): FetchArgs {
            // verify required parameter 'submissionId' is not null or undefined
            if (submissionId === null || submissionId === undefined) {
                throw new RequiredError('submissionId','Required parameter submissionId was null or undefined when calling submissionsUnaccept.');
            }
            const localVarPath = `/api/submissions/{submissionId}/unaccept`
                .replace(`{${"submissionId"}}`, encodeURIComponent(String(submissionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} submissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsWithdraw(submissionId: number, options: any = {}): FetchArgs {
            // verify required parameter 'submissionId' is not null or undefined
            if (submissionId === null || submissionId === undefined) {
                throw new RequiredError('submissionId','Required parameter submissionId was null or undefined when calling submissionsWithdraw.');
            }
            const localVarPath = `/api/submissions/{submissionId}/withdraw`
                .replace(`{${"submissionId"}}`, encodeURIComponent(String(submissionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubmissionsApi - functional programming interface
 * @export
 */
export const SubmissionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} submissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsAccept(submissionId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = SubmissionsApiFetchParamCreator(configuration).submissionsAccept(submissionId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} submissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsDelete(submissionId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = SubmissionsApiFetchParamCreator(configuration).submissionsDelete(submissionId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Submission>> {
            const localVarFetchArgs = SubmissionsApiFetchParamCreator(configuration).submissionsGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} submissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsGet_1(submissionId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Submission> {
            const localVarFetchArgs = SubmissionsApiFetchParamCreator(configuration).submissionsGet_1(submissionId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {QuickSubmission} submission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsQuickSubmit(submission: QuickSubmission, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = SubmissionsApiFetchParamCreator(configuration).submissionsQuickSubmit(submission, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} submissionId 
         * @param {number} rating 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsRate(submissionId: number, rating: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = SubmissionsApiFetchParamCreator(configuration).submissionsRate(submissionId, rating, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} submissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsReject(submissionId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = SubmissionsApiFetchParamCreator(configuration).submissionsReject(submissionId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} submissionId 
         * @param {ScheduleSubmissionRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsSchedule(submissionId: number, request: ScheduleSubmissionRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = SubmissionsApiFetchParamCreator(configuration).submissionsSchedule(submissionId, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} submissionId 
         * @param {boolean} [isAlternate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsSelect(submissionId: number, isAlternate?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = SubmissionsApiFetchParamCreator(configuration).submissionsSelect(submissionId, isAlternate, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} year 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsStats(year: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = SubmissionsApiFetchParamCreator(configuration).submissionsStats(year, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} submissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsUnaccept(submissionId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = SubmissionsApiFetchParamCreator(configuration).submissionsUnaccept(submissionId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} submissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsWithdraw(submissionId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = SubmissionsApiFetchParamCreator(configuration).submissionsWithdraw(submissionId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SubmissionsApi - factory interface
 * @export
 */
export const SubmissionsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {number} submissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsAccept(submissionId: number, options?: any) {
            return SubmissionsApiFp(configuration).submissionsAccept(submissionId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} submissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsDelete(submissionId: number, options?: any) {
            return SubmissionsApiFp(configuration).submissionsDelete(submissionId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsGet(options?: any) {
            return SubmissionsApiFp(configuration).submissionsGet(options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} submissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsGet_1(submissionId: number, options?: any) {
            return SubmissionsApiFp(configuration).submissionsGet_1(submissionId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {QuickSubmission} submission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsQuickSubmit(submission: QuickSubmission, options?: any) {
            return SubmissionsApiFp(configuration).submissionsQuickSubmit(submission, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} submissionId 
         * @param {number} rating 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsRate(submissionId: number, rating: number, options?: any) {
            return SubmissionsApiFp(configuration).submissionsRate(submissionId, rating, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} submissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsReject(submissionId: number, options?: any) {
            return SubmissionsApiFp(configuration).submissionsReject(submissionId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} submissionId 
         * @param {ScheduleSubmissionRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsSchedule(submissionId: number, request: ScheduleSubmissionRequest, options?: any) {
            return SubmissionsApiFp(configuration).submissionsSchedule(submissionId, request, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} submissionId 
         * @param {boolean} [isAlternate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsSelect(submissionId: number, isAlternate?: boolean, options?: any) {
            return SubmissionsApiFp(configuration).submissionsSelect(submissionId, isAlternate, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} year 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsStats(year: number, options?: any) {
            return SubmissionsApiFp(configuration).submissionsStats(year, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} submissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsUnaccept(submissionId: number, options?: any) {
            return SubmissionsApiFp(configuration).submissionsUnaccept(submissionId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} submissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsWithdraw(submissionId: number, options?: any) {
            return SubmissionsApiFp(configuration).submissionsWithdraw(submissionId, options)(fetch, basePath);
        },
    };
};

/**
 * SubmissionsApi - object-oriented interface
 * @export
 * @class SubmissionsApi
 * @extends {BaseAPI}
 */
export class SubmissionsApi extends BaseAPI {
    /**
     * 
     * @param {number} submissionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionsApi
     */
    public submissionsAccept(submissionId: number, options?: any) {
        return SubmissionsApiFp(this.configuration).submissionsAccept(submissionId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} submissionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionsApi
     */
    public submissionsDelete(submissionId: number, options?: any) {
        return SubmissionsApiFp(this.configuration).submissionsDelete(submissionId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionsApi
     */
    public submissionsGet(options?: any) {
        return SubmissionsApiFp(this.configuration).submissionsGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} submissionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionsApi
     */
    public submissionsGet_1(submissionId: number, options?: any) {
        return SubmissionsApiFp(this.configuration).submissionsGet_1(submissionId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {QuickSubmission} submission 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionsApi
     */
    public submissionsQuickSubmit(submission: QuickSubmission, options?: any) {
        return SubmissionsApiFp(this.configuration).submissionsQuickSubmit(submission, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} submissionId 
     * @param {number} rating 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionsApi
     */
    public submissionsRate(submissionId: number, rating: number, options?: any) {
        return SubmissionsApiFp(this.configuration).submissionsRate(submissionId, rating, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} submissionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionsApi
     */
    public submissionsReject(submissionId: number, options?: any) {
        return SubmissionsApiFp(this.configuration).submissionsReject(submissionId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} submissionId 
     * @param {ScheduleSubmissionRequest} request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionsApi
     */
    public submissionsSchedule(submissionId: number, request: ScheduleSubmissionRequest, options?: any) {
        return SubmissionsApiFp(this.configuration).submissionsSchedule(submissionId, request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} submissionId 
     * @param {boolean} [isAlternate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionsApi
     */
    public submissionsSelect(submissionId: number, isAlternate?: boolean, options?: any) {
        return SubmissionsApiFp(this.configuration).submissionsSelect(submissionId, isAlternate, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} year 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionsApi
     */
    public submissionsStats(year: number, options?: any) {
        return SubmissionsApiFp(this.configuration).submissionsStats(year, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} submissionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionsApi
     */
    public submissionsUnaccept(submissionId: number, options?: any) {
        return SubmissionsApiFp(this.configuration).submissionsUnaccept(submissionId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} submissionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionsApi
     */
    public submissionsWithdraw(submissionId: number, options?: any) {
        return SubmissionsApiFp(this.configuration).submissionsWithdraw(submissionId, options)(this.fetch, this.basePath);
    }

}

/**
 * TimeSlotsApi - fetch parameter creator
 * @export
 */
export const TimeSlotsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} timeSlotId 
         * @param {number} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeSlotsAssign(timeSlotId: number, sessionId: number, options: any = {}): FetchArgs {
            // verify required parameter 'timeSlotId' is not null or undefined
            if (timeSlotId === null || timeSlotId === undefined) {
                throw new RequiredError('timeSlotId','Required parameter timeSlotId was null or undefined when calling timeSlotsAssign.');
            }
            // verify required parameter 'sessionId' is not null or undefined
            if (sessionId === null || sessionId === undefined) {
                throw new RequiredError('sessionId','Required parameter sessionId was null or undefined when calling timeSlotsAssign.');
            }
            const localVarPath = `/api/timeslots/{timeSlotId}/assign`
                .replace(`{${"timeSlotId"}}`, encodeURIComponent(String(timeSlotId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sessionId !== undefined) {
                localVarQueryParameter['sessionId'] = sessionId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {'Short' | 'Medium' | 'Long' | 'Lightning'} [type] 
         * @param {number} [year] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeSlotsAvailable(type?: 'Short' | 'Medium' | 'Long' | 'Lightning', year?: number, options: any = {}): FetchArgs {
            const localVarPath = `/api/timeslots/available`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (year !== undefined) {
                localVarQueryParameter['year'] = year;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [year] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeSlotsGet(year?: number, options: any = {}): FetchArgs {
            const localVarPath = `/api/timeslots`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (year !== undefined) {
                localVarQueryParameter['year'] = year;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeSlotsGet_1(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling timeSlotsGet_1.');
            }
            const localVarPath = `/api/TimeSlots/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} timeslotId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeSlotsSessionsByTimeslot(timeslotId: number, options: any = {}): FetchArgs {
            // verify required parameter 'timeslotId' is not null or undefined
            if (timeslotId === null || timeslotId === undefined) {
                throw new RequiredError('timeslotId','Required parameter timeslotId was null or undefined when calling timeSlotsSessionsByTimeslot.');
            }
            const localVarPath = `/api/timeslots/{timeslotId}/sessions`
                .replace(`{${"timeslotId"}}`, encodeURIComponent(String(timeslotId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TimeSlotsApi - functional programming interface
 * @export
 */
export const TimeSlotsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} timeSlotId 
         * @param {number} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeSlotsAssign(timeSlotId: number, sessionId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = TimeSlotsApiFetchParamCreator(configuration).timeSlotsAssign(timeSlotId, sessionId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {'Short' | 'Medium' | 'Long' | 'Lightning'} [type] 
         * @param {number} [year] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeSlotsAvailable(type?: 'Short' | 'Medium' | 'Long' | 'Lightning', year?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<TimeSlot>> {
            const localVarFetchArgs = TimeSlotsApiFetchParamCreator(configuration).timeSlotsAvailable(type, year, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [year] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeSlotsGet(year?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<TimeSlot>> {
            const localVarFetchArgs = TimeSlotsApiFetchParamCreator(configuration).timeSlotsGet(year, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeSlotsGet_1(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TimeSlot> {
            const localVarFetchArgs = TimeSlotsApiFetchParamCreator(configuration).timeSlotsGet_1(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} timeslotId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeSlotsSessionsByTimeslot(timeslotId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Session>> {
            const localVarFetchArgs = TimeSlotsApiFetchParamCreator(configuration).timeSlotsSessionsByTimeslot(timeslotId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TimeSlotsApi - factory interface
 * @export
 */
export const TimeSlotsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {number} timeSlotId 
         * @param {number} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeSlotsAssign(timeSlotId: number, sessionId: number, options?: any) {
            return TimeSlotsApiFp(configuration).timeSlotsAssign(timeSlotId, sessionId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {'Short' | 'Medium' | 'Long' | 'Lightning'} [type] 
         * @param {number} [year] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeSlotsAvailable(type?: 'Short' | 'Medium' | 'Long' | 'Lightning', year?: number, options?: any) {
            return TimeSlotsApiFp(configuration).timeSlotsAvailable(type, year, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [year] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeSlotsGet(year?: number, options?: any) {
            return TimeSlotsApiFp(configuration).timeSlotsGet(year, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeSlotsGet_1(id: number, options?: any) {
            return TimeSlotsApiFp(configuration).timeSlotsGet_1(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} timeslotId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeSlotsSessionsByTimeslot(timeslotId: number, options?: any) {
            return TimeSlotsApiFp(configuration).timeSlotsSessionsByTimeslot(timeslotId, options)(fetch, basePath);
        },
    };
};

/**
 * TimeSlotsApi - object-oriented interface
 * @export
 * @class TimeSlotsApi
 * @extends {BaseAPI}
 */
export class TimeSlotsApi extends BaseAPI {
    /**
     * 
     * @param {number} timeSlotId 
     * @param {number} sessionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeSlotsApi
     */
    public timeSlotsAssign(timeSlotId: number, sessionId: number, options?: any) {
        return TimeSlotsApiFp(this.configuration).timeSlotsAssign(timeSlotId, sessionId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {'Short' | 'Medium' | 'Long' | 'Lightning'} [type] 
     * @param {number} [year] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeSlotsApi
     */
    public timeSlotsAvailable(type?: 'Short' | 'Medium' | 'Long' | 'Lightning', year?: number, options?: any) {
        return TimeSlotsApiFp(this.configuration).timeSlotsAvailable(type, year, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [year] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeSlotsApi
     */
    public timeSlotsGet(year?: number, options?: any) {
        return TimeSlotsApiFp(this.configuration).timeSlotsGet(year, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeSlotsApi
     */
    public timeSlotsGet_1(id: number, options?: any) {
        return TimeSlotsApiFp(this.configuration).timeSlotsGet_1(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} timeslotId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeSlotsApi
     */
    public timeSlotsSessionsByTimeslot(timeslotId: number, options?: any) {
        return TimeSlotsApiFp(this.configuration).timeSlotsSessionsByTimeslot(timeslotId, options)(this.fetch, this.basePath);
    }

}

/**
 * UsersApi - fetch parameter creator
 * @export
 */
export const UsersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} key 
         * @param {string} role 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersAddToRole(key: string, role: string, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling usersAddToRole.');
            }
            // verify required parameter 'role' is not null or undefined
            if (role === null || role === undefined) {
                throw new RequiredError('role','Required parameter role was null or undefined when calling usersAddToRole.');
            }
            const localVarPath = `/api/users/{key}/roles/{role}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"role"}}`, encodeURIComponent(String(role)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet(name?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/Users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} key 
         * @param {string} role 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIsInRole(key: string, role: string, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling usersIsInRole.');
            }
            // verify required parameter 'role' is not null or undefined
            if (role === null || role === undefined) {
                throw new RequiredError('role','Required parameter role was null or undefined when calling usersIsInRole.');
            }
            const localVarPath = `/api/users/{key}/roles/{role}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"role"}}`, encodeURIComponent(String(role)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} key 
         * @param {string} role 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersRemoveFromRole(key: string, role: string, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling usersRemoveFromRole.');
            }
            // verify required parameter 'role' is not null or undefined
            if (role === null || role === undefined) {
                throw new RequiredError('role','Required parameter role was null or undefined when calling usersRemoveFromRole.');
            }
            const localVarPath = `/api/users/{key}/roles/{role}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"role"}}`, encodeURIComponent(String(role)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} key 
         * @param {string} role 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersAddToRole(key: string, role: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).usersAddToRole(key, role, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet(name?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UserInfo>> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).usersGet(name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} key 
         * @param {string} role 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIsInRole(key: string, role: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).usersIsInRole(key, role, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} key 
         * @param {string} role 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersRemoveFromRole(key: string, role: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).usersRemoveFromRole(key, role, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} key 
         * @param {string} role 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersAddToRole(key: string, role: string, options?: any) {
            return UsersApiFp(configuration).usersAddToRole(key, role, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet(name?: string, options?: any) {
            return UsersApiFp(configuration).usersGet(name, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} key 
         * @param {string} role 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIsInRole(key: string, role: string, options?: any) {
            return UsersApiFp(configuration).usersIsInRole(key, role, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} key 
         * @param {string} role 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersRemoveFromRole(key: string, role: string, options?: any) {
            return UsersApiFp(configuration).usersRemoveFromRole(key, role, options)(fetch, basePath);
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @param {string} key 
     * @param {string} role 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersAddToRole(key: string, role: string, options?: any) {
        return UsersApiFp(this.configuration).usersAddToRole(key, role, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [name] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersGet(name?: string, options?: any) {
        return UsersApiFp(this.configuration).usersGet(name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} key 
     * @param {string} role 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersIsInRole(key: string, role: string, options?: any) {
        return UsersApiFp(this.configuration).usersIsInRole(key, role, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} key 
     * @param {string} role 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersRemoveFromRole(key: string, role: string, options?: any) {
        return UsersApiFp(this.configuration).usersRemoveFromRole(key, role, options)(this.fetch, this.basePath);
    }

}

